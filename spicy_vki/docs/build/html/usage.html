<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Functions &mdash; SPICY 1.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Release History" href="version_history.html" />
    <link rel="prev" title="SPICY: References and material" href="material.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            SPICY
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">SPICY: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="material.html">SPICY: References and material</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="version_history.html">Release History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SPICY</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Functions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">¶</a></h1>
<p>SPICY accepts input data of varying dimension, which are all converted into lists of 1D arrays.</p>
<dl class="py class">
<dt class="sig sig-object py" id="spicy_class.spicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">spicy_class.</span></span><span class="sig-name descname"><span class="pre">spicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ST</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spicy_class.html#spicy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spicy_class.spicy" title="Permalink to this definition">¶</a></dt>
<dd><p>SPICY (Super-resolution and Pressure from Image veloCimetrY) is a software 
developed at the von Karman Institute to perform data assimilation by means 
of Radial Basis Functions (RBF). The framework works both for structured and 
unstructered data. Currently, the main application is to perform a regression
of image velocimetry data and then solve the pressure equation. However, the framework 
can be readily extended to regression of other fields (e.g. temperature fields).</p>
<p>The original article by Sperotto et al. (2022) can be found at:
<a class="reference external" href="https://arxiv.org/abs/2112.12752">https://arxiv.org/abs/2112.12752</a></p>
<p>YouTube channel with hands-on tutorials can be found at:
<a class="reference external" href="https://www.youtube.com/&#64;spicyVKI">https://www.youtube.com/&#64;spicyVKI</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.__init__">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ST</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of an instance of the spicy class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>list of 1D numpy.ndarray</em>) – If the instance is to be used to solve a regression problem, this 
list contains the target data. data is an array [u] if the model is
scalar, a list with two arrays [u, v] for a 2D vector field and a list of 
three arrays [u, v, w] for a 3D field. 
If the instance is to be used to solve the Poisson equation,
this list contains the forcing term on the RHS of the Poisson equation.</p></li>
<li><p><strong>grid_point</strong> – Is a list of arrays containing the grid points: [X_G ,Y_G] in 2D and
[X_G, Y_G, Z_G] in 3D.</p></li>
<li><p><strong>basis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – <p>This defines the basis. Currently, the two options are</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'gauss'</span></code>, i.e. Gaussian RBFs exp(-c_r**2*d(x))</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'c4'</span></code>, i.e. C4 RBFs (1+d(x+)/c_r)**5(1-d(x+)/c_r)**5</p></li>
</ul>
</p></li>
<li><p><strong>ST</strong> (<em>list of 1D numpy.ndarray</em>) – Is a list of arrays collecting Reynolds stresses. This is empty if
the model is ‘scalar’ or ‘laminar’. If the model is RANSI (isotropic), it
contains [uu’]. If the model is RANSA (anisotropic), it contains [uu, vv, uv] 
in 2D and [uu, vv, ww, uv, uw, vw] in 3D.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>General attributes:</dt><dd><p>X_G, Y_G, Z_G: coordinates of the point in which the data is available
u : function to learn or u component in case of velocity field
v: v component in case of velocity field (absent for scalar)
w: w component in case of velocity field (absent for scalar)</p>
</dd>
<dt>If constraints are assigned:</dt><dd><p>X_D, Y_D, Z_D: coordinates of the points with Dirichlet (D) conditions
c_D: values of the D conditions</p>
<p>X_N, Y_N, Z_N: coordinates of the points with Neumann (N) conditions
n_x, n_y, n_z: normal versors where N conditions are introduced
c_N_X, c_N_Y, c_N_Z: values of the N conditions</p>
<p>X_Div, Y_Div, Z_Div: coordinates of the points with Div conditions</p>
</dd>
<dt>If clustering is done:</dt><dd><p>r_mM: vector collecting minimum (m) and maximum (M) radious of the RBFs 
eps_l: scalar controlling the value of an RBF at the closest RBF neighbor               
X_C, Y_C, Z_C : coordinates of the cluster centers/collocations 
c_k: shape parameters of the RBFs 
d_k: diameters of the rbfs</p>
</dd>
<dt>If problem is assembled:</dt><dd><p>A: matrix A in the linear system
B: matrix B in the linear system
b_1: vector b_1 in the linear systems
b_2: vector b_2 in the linear system</p>
</dd>
<dt>If computation is done: </dt><dd><p>weights: weights of the RBF regression 
lambda: Lagrange multipliers of the RBF regression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.clustering">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">clustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Areas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_mM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.01,</span> <span class="pre">0.3]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>This function defines the collocation of a set of RBFs using the multi-
level clustering first introduced in the article. Note that we modified the slightly original formulation
to ease the programming; see video tutorials for more.
The function must be run before the constraint definition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_K</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – This contains the n_k vector in eq (33) in the paper; this is the 
list of expected particles per RBF at each level. For example, if n_K=[4,10], 
it means that the clustering will try to have a first level with RBFs whose size
seeks to embrace 4 points, while the second level seeks to embrace
10 points, etc. The length of this vector automatically defines the
number of levels.</p></li>
<li><p><strong>Areas</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – List of the refinement regions for each clustering level. If no 
refinement is needed, then this should be a list of empty
lists (default option). Currently not implemented in 3D.</p></li>
<li><p><strong>r_mM</strong> (<em>list of two float values</em>) – default=[0.01, 0.3].
This contains the minimum and the maximum RBF’s radiuses. This is
defined as the distance from the collocation point at which the RBF
value is 0.5.</p></li>
<li><p><strong>eps_l</strong> – default=0.7.
This is the value that a RBF will have at its closest neighbour. It 
is used to define the shape factor from the clustering results.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.scalar_constraints">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">scalar_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DIR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NEU</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_RBF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.scalar_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions sets the boundary conditions for a scalar problem. The
function must be run after the clustering is carried out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DIR</strong> (<em>list of 1D numpy.ndarray</em>) – This contains the info for the Dirichlet conditions. If the model is
2D, then this has [X_D, Y_D, c_D]. If the model is 3D, then this has
[X_D, Y_D, Z_D, c_D]. Here X_D, Y_D, Z_D are the coordinates of the
poins where the value c_D is set.</p></li>
<li><p><strong>NEU</strong> (<em>list of 1D numpy.ndarray</em>) – This contains the info for the Neuman conditions. If the model is 2D,
then this has [X_N, Y_N, n_x, n_y, c_N]. If the model is 3D, then 
this has [X_N, Y_N, Z_N, n_x, n_y, n_z, c_N]. Here X_N, Y_N, Z_N are
the coordinates of the poins where the value c_N is set for the 
directional derivative along the normal direction n_x, n_y, n_z.</p></li>
<li><p><strong>extra_RBF</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – default = True
This is a flag to put extra collocation points where a constraint is
set. It can improve the solution of the linear system as constraints
remove degrees of freedom.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.vector_constraints">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">vector_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DIR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NEU</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DIV</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_RBF</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.vector_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p># This functions sets the boundary conditions for a laminar problem. The
function must be run after the clustering was carried out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DIR</strong> (<em>list of 1D numpy.ndarray</em>) – <p>This contains the info for the Dirichlet conditions.
If the model is 2D, then this has [X_D, Y_D, c_D_X, c_D_Y].
If the model is 3D, then this has [X_D, Y_D, Z_D, c_D_X, c_D_Y, c_D_Z].</p>
<p>Here X_D, Y_D, Z_D are the coordinates of the poins where the value c_D_X,
c_D_Y, c_D_Z is set in 2 or 3 dimensions.</p>
</p></li>
<li><p><strong>NEU</strong> (<em>list of 1D numpy.ndarray</em>) – <p>This contains the info for the Neuman conditions.
If the model is 2D, then this has [X_N, Y_N, n_x, n_y, c_N_X, c_N_Y].
If the model is 3D, then this has [X_N, Y_N, Z_n, n_x, n_y, n_z, c_N_X, c_N_Y, c_N_Z].</p>
<p>Here X_N, Y_N, Z_N are the coordinates of the poins where the value c_N_X,
c_N_Y, c_N_Z is set for the directional derivative along the 
normal direction n_x,n_y,n_z</p>
</p></li>
<li><p><strong>DIV</strong> (<em>list of 1D numpy.ndarray</em>) – <p>This contains the info for the Divergence free conditions.
If the model is 2D, then this has [X_Div, Y_Div].
If the model is 3D, then this has [X_Div, Y_Div, Z_Div].</p>
<p>Here X_Div, Y_Div, Z_Div are the coordinates of the poins where the
divergence-free condition is imposed.</p>
</p></li>
<li><p><strong>extra_RBF</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – default=True
This is a flag to put extra collocation points where a constraint is
set. It can improve the solution of the linear system as constraints
remove degrees of freedom</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.plot_RBFs">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">plot_RBFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.plot_RBFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to check the spreading of the RBFs after the clustering.
This function generates several plots. It produces no new variable in SPICY.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>l</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – This defines the cluster level of RBF that will be visualized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Assembly_Poisson">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Assembly_Poisson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Assembly_Poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>This function assembly the matrices A, B, b_1, b_2 for the Poisson problem.
These are eqs. (31a) - (31d) in the original paper (see also video tutorial 1 for more info)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_hb</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – <p>When solving the Poisson equation, global basis elements such as polynomials or series
expansions can be of great help. This is evident if one note that the eigenfunctions of 
the Laplace operator are harmonics. 
In a non-homogeneous problem, once could homogenize the basis. This will be proposed for the next relase
(which will align with Manuel’s paper). The idea is the following: if the homogeneization is well done and
the basis is well chosen, then we do not need constraints for these extra terms of the basis.</p>
<p>For the moment, we let the user introduce the number of extra_basis. 
These will be sine and cosine bases, which are orthogonal in [-1,1].
In 1D, they are defined as : sines_n=np.sin(2*np.pi*(n)*x); cos_n=np.cos(np.pi/2*(2*n+1)*x)
Given n_hb, we will have that the first n_hb are sines the last n_hb will be cosines.
This defines the basis phi_h_n, with n an index from 0 to n_hb**4 in 2D.</p>
<p>In 2D, assuming separation of variables, we will take phi_h_nm=phi_n(x)*phi_m(y).
Similarly, in 3D will be phi_nmk=phi_n(x)*phi_m(y)*phi_k(z).
For stability purposes, the largest tolerated value at the moment is 10!.</p>
<p>For an homogeneous problem, the chosen basis needs no constraints.</p>
<p>!!!!!!!!!!!!!!!#### this feature is currently under development #####!!!!!!!!!!!!!!!!</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Assembly_Regression">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Assembly_Regression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Assembly_Regression" title="Permalink to this definition">¶</a></dt>
<dd><p>This function assembly the matrices A, B, C, D from the paper (see video tutorial 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_hb</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – <p>int</p>
<blockquote>
<div><p>Also for a regression, the harmonic basis can improve the regression
as they can model global trends which are similar to a low order
polynomial. Furthermore, for homogenous problem, they automatically
fulfill the boundary conditions.</p>
</div></blockquote>
<p>See the same entry in the function ‘Assembly_Poisson’</p>
</p></li>
<li><p><strong>alpha_div</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – This enables a divergence free penalty in the entire flow field.
The higher this parameter, the more SPICY penalizes errors in the divergence-free 
condition. This is particularly important to obtain good derivatives 
for the pressure computation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Solve">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>This function solves the constrained quadratic problem A, B, b_1, b_2.
The method is universal for 2D/3D problems as well as laminar/Poisson problems.</p>
<p>The input parameters are the class itself and the desired condition 
number of A which is fixed based on its largest and smallest eigenvalue</p>
<p>The function assigns the weights ‘w’ and the Lagrange multipliers
Lambda to the class. The weights are computed for the min/max scaled problem,
i.e. the right hand-side of the linear system is normalized. The assigned
weights are rescaled by self.rescale to get the real, physical quantities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>K_cond</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Default 1e12.
This is the regularization parameter. It fixes the condition number (see Video 1)
The estimation is based such that the regularize matrix has the condition
number k_cond. For this, we compute the max and the min eigenvalue.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Get_Sol">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Get_Sol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Get_Sol" title="Permalink to this definition">¶</a></dt>
<dd><p>This function evaluates the solution of the linear system on an arbitrary
set of points on the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grid</strong> – Contains the points at which the source term is evaluated
If the model is 2D, then this has [X_P, Y_P].
If the model is 3D, then this has [X_P, Y_P, Z_P].</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>U_sol, V_sol, W_sol.  
Depending on model=’scalar/laminar’ and type=’2D/3D’    
If scalar, the solution is only U_sol.
If laminar and 2D, the solution is U_sol, V_sol
If laminar and 3D, the solution is U_sol, V_sol and W_sol</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Get_first_Derivatives">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Get_first_Derivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Get_first_Derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>This function evaluates the first derivative of the solution of the
linear system on an arbitrary set of points on the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grid</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – Contains the points at which the source term is evaluated
If the model is 2D, then this has [X_P, Y_P].
If the model is 3D, then this has [X_P, Y_P, Z_P].</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dUdX, dUdY, dUdX, dVdX, dVdY, dVdX, dWdX, dWdY, dWdX.
Depending on model = ‘scalar/laminar’ and type = ‘2D/3D’    
If scalar and 2D, the output is dUdX, dUdY
If scalar and 3D, the output is dUdX, dUdY, dUdZ        
If laminar and 2D, the solution is dUdx, dUdY, dVdX, dVdY
If laminar and 3D, the solution is dUdx, dUdY, dUdX, dVdX, dVdY, dVdX, dWdX, dWdY, dWdX</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Evaluate_Source_Term">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Evaluate_Source_Term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Evaluate_Source_Term" title="Permalink to this definition">¶</a></dt>
<dd><p>This function evaluates the source term on the right hand side of
equation (21) in the paper (see video tutorial 1 for more info)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – Contains the points at which the source term is evaluated
If the model is 2D, then this has [X_P, Y_P].
If the model is 3D, then this has [X_P, Y_P, Z_P].</p></li>
<li><p><strong>rho</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Density of the fluid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>source_term
R.h.s. of equation (21).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spicy_class.spicy.Get_Pressure_Neumann">
<span class="sig-prename descclassname"><span class="pre">spicy_class.spicy.</span></span><span class="sig-name descname"><span class="pre">Get_Pressure_Neumann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#spicy_class.spicy.Get_Pressure_Neumann" title="Permalink to this definition">¶</a></dt>
<dd><p>This function evaluates the Neumann boundary conditions for the pressure
integration in equation (29) from the original paper (see video tutorial 1 for more info)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – Contains the points at which the Neumann constraint is evaluated.
If the model is 2D, then this has [X_P, Y_P].
If the model is 3D, then this has [X_P, Y_P, Z_P].</p></li>
<li><p><strong>normals</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a>) – Contains normals of the points at which the Neumann constraint is evaluated.
If the model is 2D, then this has [n_x, n_y].
If the model is 3D, then this has [n_x, n_y, n_z].</p></li>
<li><p><strong>rho</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Density of the fluid.</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Dynamic viscosity of the fluid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>P_neu
Normal pressure in equation (29).</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="material.html" class="btn btn-neutral float-left" title="SPICY: References and material" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="version_history.html" class="btn btn-neutral float-right" title="Release History" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, P. Sperotto, M. Ratz, M. A. Mendez.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>